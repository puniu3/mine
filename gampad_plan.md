# Xbox コントローラー対応仕様書 (Xbox Controller Support Plan)

## 1. 概要 (Overview)
HTML5 Gamepad API (`navigator.getGamepads()`) を使用して、Xboxコントローラー（およびXInput対応コントローラー）をサポートするための設計仕様です。
マウス操作を前提とした現在のゲームプレイ（ブロックの選択、設置、破壊）を、コントローラーでも直感的に行えるように「仮想カーソル（Virtual Cursor）」方式を採用します。

## 2. キー割り当て (Key Assignments)

| アクション | Xbox コントローラー入力 | 備考 |
| :--- | :--- | :--- |
| **移動 (左右)** | 左スティック (Left Stick) | アナログ入力。閾値を超えた場合に移動判定。 |
| **ジャンプ** | A ボタン | `Space` / `ArrowUp` 相当。 |
| **クライム (足元に設置)** | X ボタン | `KeyS` / `ArrowDown` 相当。「足元にブロックを置いて登る」アクション。 |
| **カーソル移動** | 右スティック (Right Stick) | 画面上の仮想カーソルを操作します。 |
| **アクション (破壊)** | RT (Right Trigger) | カーソル位置のブロックを破壊。 |
| **アクション (破壊)** | LT (Left Trigger) | カーソル位置にブロックを設置。通常の設置制限を適用。 |
| **ホットバー選択 (左)** | LB (Left Bumper) | 選択スロットを左へ切り替え。 |
| **ホットバー選択 (右)** | RB (Right Bumper) | 選択スロットを右へ切り替え。 |

### 補足事項
- **デッドゾーン (Deadzone):** スティック入力には 0.1～0.2 程度のデッドゾーンを設け、ドリフトを防止します。
- **UI操作:** クラフト画面（DOM要素）およびタイトル画面ではD-PADでボタンを選択、Aで決定、Bで閉じる。

## 3. 技術的アプローチ (Technical Approach)

### 3.1 入力処理 (`src/input.js`)
現在のイベントリスナー方式に加え、毎フレームポーリングを行う処理を追加します。

- **`updateGamepad()` 関数:** メインループ (`main.js` の `tick`) または `input.js` 内部で毎フレーム呼び出します。
- **接続検知:** `gamepadconnected` イベントでコントローラー接続を検知し、ポーリングを開始します。

### 3.2 仮想カーソル (Virtual Cursor)
マウスがない環境でもブロックを選択できるように、画面上に照準（クロスヘア）を表示します。

- **座標管理:** `cursorX`, `cursorY` を状態として保持します。
- **移動ロジック:** 右スティックの入力値 (`-1.0` ～ `1.0`) に感度係数を掛けた値を毎フレーム加算します。
- **表示:** `renderer.js` または専用の `ui_manager.js` で、現在の `cursorX, Y` の位置にカーソル画像を描画します。
- **範囲制限:** カーソルが画面外に出ないようにクランプ (Clamp) します。

### 3.3 アクション連携 (`src/actions.js`)
- 現在の `handlePointer(x, y)` 関数はそのまま利用可能です。
- RT押下時に、マウスのクリックイベントの代わりに `input.gamepad.cursorX`, `input.gamepad.cursorY` を `handlePointer` に渡します。

## 4. 実装ステップ (Implementation Steps)

1.  **入力モジュールの拡張:** `src/input.js` に `pollGamepads()` メソッドを追加し、スティック軸とボタン状態を取得。
2.  **カーソル表示:** 仮想カーソルのレンダリング処理を追加。
3.  **アクションの配線:** `src/main.js` のループ内で、ゲームパッド入力を `player.tick()` や `actions.handlePointer()` に渡すロジックを統合。
4.  **UIナビゲーション:** インベントリ画面でのカーソル操作の検証と調整。
